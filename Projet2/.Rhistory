print(Hbest)
vectValeurs = 1:N
vectValeurs[N+1] = N*(N+1)/2
vectCoord = sample(0:1,N+1,replace = TRUE)
nmax2 = 10000
betta0 = 0.01
vectCoordBest = vectCoord
Hbest = fctH(vectValeurs,vectCoord)
valeursH = c()
for (i in 1:nmax2) {
betta = betta0 * sqrt(i)
vectCoord = transition1(vectValeurs,vectCoord,betta)
valeursH[i] = fctH(vectValeurs,vectCoord)
if(valeursH[i]<Hbest){
Hbest = valeursH[i]
vectCoordBest = vectCoord
}
}
plot(valeursH)
print(Hbest)
vectValeurs = sample(1:N,d,replace = TRUE)
vectCoord = sample(0:1,d,replace = TRUE)
nmax2 = 1000
betta0 = 0.2
vectCoordBest = vectCoord
Hbest = fctH(vectValeurs,vectCoord)
valeursH = c()
for (i in 1:nmax2) {
betta = betta0 * sqrt(i)
vectCoord = transition2(vectValeurs,vectCoord,betta)
valeursH[i] = fctH(vectValeurs,vectCoord)
if(valeursH[i]<Hbest){
Hbest = valeursH[i]
vectCoordBest = vectCoord
}
}
plot(valeursH)
print(Hbest)
vectValeurs = sample(1:N,d,replace = TRUE)
vectCoord = sample(0:1,d,replace = TRUE)
nmax2 = 1000
betta0 = 0.2
vectCoordBest = vectCoord
Hbest = fctH(vectValeurs,vectCoord)
valeursH = c()
for (i in 1:nmax2) {
betta = betta0 * sqrt(i)
vectCoord = transition2(vectValeurs,vectCoord,betta)
valeursH[i] = fctH(vectValeurs,vectCoord)
if(valeursH[i]<Hbest){
Hbest = valeursH[i]
vectCoordBest = vectCoord
}
}
plot(valeursH)
print(Hbest)
N = 2000 # nombre maximal que peut atteindre une valeur
d = 1000 # nombre de valeurs  dans le vecteur
# Fonction Elementaires ---------------------------------------------------
fctH = function(vectValeurs,vectCoordones) {
loc1 = sum(vectValeurs*vectCoordones)
loc2 = sum(vectValeurs * (1-vectCoordones))
return(abs(loc1 - loc2))
}
# Premiere Transition -----------------------------------------------------
transition1 = function(vectValeurs,vectCoord,betta) {
# on tire une valeur au hasard et on change son appartenance
coord = sample(1:d,1)
vectCoordNew = vectCoord
vectCoordNew[coord] = 1-vectCoordNew[coord]
Delta = fctH(vectValeurs,vectCoordNew)-fctH(vectValeurs,vectCoord)
alpha = min(exp(-betta * Delta),1)
logAlpha = min(-betta * Delta,0)
U = runif(1)
if(log(U) < logAlpha) {return(vectCoordNew)}
else { return(vectCoord)}
}
transition2 = function(vectValeurs,vectCoord,betta) {
bool = (sum(vectValeurs * vectCoord) > sum(vectValeurs* (1-vectCoord)))*1
# bool = 1 si la somme associee aux 1 du vecteur coordonnes est plus grande
# que la somme associee au 0 du vecteur coordonnes
vectCoordNew = vectCoord
coord = sample(which(vectCoord==bool),1)
vectCoordNew[coord] = 1 - vectCoordNew[coord]
Delta = fctH(vectValeurs,vectCoordNew)-fctH(vectValeurs,vectCoord)
Qxy = 1/(length(which(vectCoord == vectCoord[coord])))
# la somme des elements dans l'autre ensemble que coord + la valeur de celui-ci
terme1 = sum(vectValeurs* (1-bool)) + vectValeurs[coord]
# la somme des elements dans le mm ensemble que coord - la valeur de celui-ci
terme2 = sum(vectValeurs * bool) - vectValeurs[coord]
if(terme1 < terme2) {
# Dans ce cas la transition de y a x est impossible et la transition de x a y est toujours accepte
Qyx = 0
}
else{
Qyx = 1/(length(which(vectCoord == 1-vectCoord[coord]))+1)
}
# on passe a l'echelle logarithmique pour qu'on ait pas un underflow numerique a cause des grandes valeurs
logAlpha = min((-betta * Delta)+ log(Qxy)-log(Qyx),0)
U = runif(1)
#print(alpha)
if(log(U) < logAlpha) {return(vectCoordNew)}
else { return(vectCoord)}
}
vectValeurs = sample(1:N,d,replace = TRUE)
vectCoord = sample(0:1,d,replace = TRUE)
nmax2 = 1000
betta0 = 0.2
vectCoordBest = vectCoord
Hbest = fctH(vectValeurs,vectCoord)
valeursH = c()
for (i in 1:nmax2) {
betta = betta0 * sqrt(i)
vectCoord = transition2(vectValeurs,vectCoord,betta)
valeursH[i] = fctH(vectValeurs,vectCoord)
if(valeursH[i]<Hbest){
Hbest = valeursH[i]
vectCoordBest = vectCoord
}
}
plot(valeursH)
print(Hbest)
vectValeurs = sample(1:N,d,replace = TRUE)
vectCoord = sample(0:1,d,replace = TRUE)
nmax2 = 1000
betta0 = 0.2
vectCoordBest = vectCoord
Hbest = fctH(vectValeurs,vectCoord)
valeursH = c()
for (i in 1:nmax2) {
betta = betta0 * sqrt(i)
vectCoord = transition2(vectValeurs,vectCoord,betta)
valeursH[i] = fctH(vectValeurs,vectCoord)
if(valeursH[i]<Hbest){
Hbest = valeursH[i]
vectCoordBest = vectCoord
}
}
plot(valeursH)
print(Hbest)
N = 2000 # nombre maximal que peut atteindre une valeur
d = 1000 # nombre de valeurs  dans le vecteur
# Fonction Elementaires ---------------------------------------------------
fctH = function(vectValeurs,vectCoordones) {
loc1 = sum(vectValeurs*vectCoordones)
loc2 = sum(vectValeurs * (1-vectCoordones))
return(abs(loc1 - loc2))
}
# Premiere Transition -----------------------------------------------------
transition1 = function(vectValeurs,vectCoord,betta) {
# on tire une valeur au hasard et on change son appartenance
coord = sample(1:d,1)
vectCoordNew = vectCoord
vectCoordNew[coord] = 1-vectCoordNew[coord]
Delta = fctH(vectValeurs,vectCoordNew)-fctH(vectValeurs,vectCoord)
alpha = min(exp(-betta * Delta),1)
logAlpha = min(-betta * Delta,0)
U = runif(1)
if(log(U) < logAlpha) {return(vectCoordNew)}
else { return(vectCoord)}
}
vectValeurs = sample(1:N,d,replace = TRUE)
vectCoord = sample(0:1,d,replace = TRUE)
nmax1 = 100
betta0 = 0.05
vectCoordBest = vectCoord
Hbest = fctH(vectValeurs,vectCoord)
valeursH = c()
for (i in 1:nmax1) {
betta = betta0 * sqrt(i)
vectCoord = transition1(vectValeurs,vectCoord,betta)
valeursH[i] = fctH(vectValeurs,vectCoord)
if(valeursH[i]<Hbest){
Hbest = valeursH[i]
vectCoordBest = vectCoord
}
}
plot(valeursH)
print(Hbest)
transition2 = function(vectValeurs,vectCoord,betta) {
bool = (sum(vectValeurs * vectCoord) > sum(vectValeurs* (1-vectCoord)))*1
# bool = 1 si la somme associee aux 1 du vecteur coordonnes est plus grande
# que la somme associee au 0 du vecteur coordonnes
vectCoordNew = vectCoord
coord = sample(which(vectCoord==bool),1)
vectCoordNew[coord] = 1 - vectCoordNew[coord]
Delta = fctH(vectValeurs,vectCoordNew)-fctH(vectValeurs,vectCoord)
Qxy = 1/(length(which(vectCoord == vectCoord[coord])))
# la somme des elements dans l'autre ensemble que coord + la valeur de celui-ci
terme1 = sum(vectValeurs* (1-bool)) + vectValeurs[coord]
# la somme des elements dans le mm ensemble que coord - la valeur de celui-ci
terme2 = sum(vectValeurs * bool) - vectValeurs[coord]
if(terme1 < terme2) {
# Dans ce cas la transition de y a x est impossible et la transition de x a y est toujours accepte
Qyx = 0
}
else{
Qyx = 1/(length(which(vectCoord == 1-vectCoord[coord]))+1)
}
# on passe a l'echelle logarithmique pour qu'on ait pas un underflow numerique a cause des grandes valeurs
logAlpha = min((-betta * Delta)+ log(Qxy)-log(Qyx),0)
U = runif(1)
#print(alpha)
if(log(U) < logAlpha) {return(vectCoordNew)}
else { return(vectCoord)}
}
vectValeurs = sample(1:N,d,replace = TRUE)
vectCoord = sample(0:1,d,replace = TRUE)
nmax2 = 1000
betta0 = 0.2
vectCoordBest = vectCoord
Hbest = fctH(vectValeurs,vectCoord)
valeursH = c()
for (i in 1:nmax2) {
betta = betta0 * sqrt(i)
vectCoord = transition2(vectValeurs,vectCoord,betta)
valeursH[i] = fctH(vectValeurs,vectCoord)
if(valeursH[i]<Hbest){
Hbest = valeursH[i]
vectCoordBest = vectCoord
}
}
plot(valeursH)
print(Hbest)
vectValeurs = sample(1:N,d,replace = TRUE)
vectCoord = sample(0:1,d,replace = TRUE)
nmax2 = 1000
betta0 = 0.2
vectCoordBest = vectCoord
Hbest = fctH(vectValeurs,vectCoord)
valeursH = c()
for (i in 1:nmax2) {
betta = betta0 * sqrt(i)
vectCoord = transition2(vectValeurs,vectCoord,betta)
valeursH[i] = fctH(vectValeurs,vectCoord)
if(valeursH[i]<Hbest){
Hbest = valeursH[i]
vectCoordBest = vectCoord
}
}
plot(valeursH)
print(Hbest)
vectValeurs = sample(1:N,d,replace = TRUE)
vectCoord = sample(0:1,d,replace = TRUE)
nmax2 = 1000
betta0 = 0.2
vectCoordBest = vectCoord
Hbest = fctH(vectValeurs,vectCoord)
valeursH = c()
for (i in 1:nmax2) {
betta = betta0 * sqrt(i)
vectCoord = transition2(vectValeurs,vectCoord,betta)
valeursH[i] = fctH(vectValeurs,vectCoord)
if(valeursH[i]<Hbest){
Hbest = valeursH[i]
vectCoordBest = vectCoord
}
}
plot(valeursH)
print(Hbest)
## Algorithme de Metropolis pour le coloriage des departements ##
## en  L = 60 niveaux de gris ##
## Nombre de departements
N = 95
## Matrice de voisinage des departements
## V[i,j] = 1 si les departements i et j se touchent
V <- array(0,dim=c(N,N))
V[1,39]=1; V[1,74]=1; V[1,73]=1; V[1,38]=1; V[1,69]=1; V[1,71]=1;
V[2,8]=1; V[2,51]=1; V[2,77]=1; V[2,60]=1; V[2,80]=1; V[2,59]=1;
V[3,71]=1; V[3,42]=1; V[3,63]=1; V[3,23]=1; V[3,18]=1; V[3,58]=1;
V[4,5]=1; V[4,6]=1; V[4,83]=1; V[4,84]=1; V[4,26]=1;
V[5,26]=1; V[5,38]=1; V[5,73]=1;
V[6,83]=1;
V[7,26]=1; V[7,30]=1; V[7,38]=1; V[7,43]=1; V[7,48]=1;
V[7,42]=1; V[7,84]=1;
V[8,51]=1; V[8,55]=1;
V[9,11]=1; V[9,66]=1; V[9,31]=1;
V[10,21]=1; V[10,89]=1; V[10,77]=1; V[10,51]=1; V[10,52]=1;
V[11,66]=1; V[11,31]=1; V[11,81]=1; V[11,34]=1;
V[12,15]=1; V[12,48]=1; V[12,30]=1; V[12,34]=1; V[12,81]=1;
V[12,82]=1; V[12,46]=1;
V[13,83]=1; V[13,84]=1; V[13,30]=1;
V[14,50]=1; V[14,61]=1; V[14,27]=1;
V[15,19]=1; V[15,63]=1; V[15,43]=1; V[15,48]=1; V[15,46]=1;
V[16,17]=1; V[16,79]=1; V[16,86]=1; V[16,87]=1; V[16,24]=1;
V[17,85]=1; V[17,79]=1; V[17,24]=1; V[17,33]=1;
V[18,23]=1; V[18,36]=1; V[18,41]=1; V[18,45]=1; V[18,58]=1;
V[19,24]=1; V[19,87]=1; V[19,23]=1; V[19,63]=1; V[19,46]=1;
V[21,52]=1; V[21,70]=1; V[21,39]=1; V[21,71]=1; V[21,58]=1;
V[21,89]=1;
V[22,29]=1; V[22,56]=1; V[22,35]=1;
V[23,36]=1; V[23,63]=1; V[23,87]=1;
V[24,33]=1; V[24,87]=1; V[24,46]=1; V[24,47]=1;
V[25,39]=1; V[25,70]=1; V[25,90]=1; V[25,68]=1;
V[26,38]=1; V[26,84]=1;
V[27,28]=1; V[27,61]=1; V[27,76]=1; V[27,60]=1; V[27,95]=1;
V[27,78]=1;
V[28,61]=1; V[28,41]=1; V[28,45]=1; V[28,91]=1; V[28,78]=1;
V[28,72]=1;
V[29,56]=1;
V[30,34]=1; V[30,48]=1; V[30,84]=1;
V[31,32]=1; V[31,82]=1; V[31,81]=1; V[31,65]=1;
V[32,40]=1; V[32,47]=1; V[32,82]=1; V[32,65]=1; V[32,64]=1;
V[33,40]=1; V[33,47]=1;
V[34,81]=1;
V[35,53]=1; V[35,50]=1; V[35,44]=1; V[35,56]=1;
V[36,37]=1; V[36,41]=1; V[36,87]=1; V[36,86]=1;
V[37,41]=1; V[37,49]=1; V[37,72]=1; V[37,86]=1;
V[38,42]=1; V[38,69]=1; V[38,73]=1;
V[39,71]=1; V[39,70]=1;
V[40,47]=1; V[40,64]=1;
V[41,45]=1; V[41,72]=1;
V[42,63]=1; V[42,43]=1; V[42,63]=1; V[42,69]=1; V[42,71]=1;
V[43,63]=1; V[43,48]=1;
V[44,49]=1; V[44,85]=1; V[44,56]=1;
V[45,91]=1; V[45,77]=1; V[45,89]=1 ; V[45,58]=1;
V[46,47]=1; V[46,82]=1;
V[47,82]=1;
V[49,53]=1; V[49,72]=1; V[49,86]=1; V[49,79]=1; V[49,85]=1;
V[50,61]=1; V[50,53]=1;
V[51,52]=1; V[51,55]=1; V[51,77]=1;
V[52,55]=1; V[52,88]=1; V[52,70]=1;
V[53,61]=1; V[53,72]=1;
V[54,55]=1; V[54,57]=1; V[54,88]=1;
V[55,88]=1;
V[57,67]=1;
V[58,71]=1; V[58,89]=1;
V[59,62]=1; V[59,80]=1;
V[60,76]=1; V[60,95]=1; V[60,77]=1; V[60,80]=1;
V[61,72]=1;
V[62,80]=1;
V[64,65]=1;
V[67,68]=1; V[67,88]=1;
V[68,90]=1; V[68,88]=1;
V[69,71]=1;
V[70,90]=1; V[70,88]=1;
V[73,74]=1;
V[75,94]=1; V[75,93]=1; V[75,92]=1;
V[76,80]=1;
V[77,89]=1; V[77,91]=1; V[77,93]=1; V[77,94]=1; V[77,95]=1;
V[78,91]=1; V[78,92]=1; V[78,95]=1;
V[79,85]=1; V[79,86]=1;
V[81,82]=1;
V[83,84]=1;
V[86,87]=1;
V[88,90]=1;
V[91,92]=1; V[91,94]=1;
V[92,93]=1; V[92,94]=1; V[92,95]=1;
V[93,94]=1; V[93,95]=1;
V = t(V) +V
## Nombre de niveaux de gris L souhaite
L = 4
## Nombre d'iterations de l'algorithme
nmax = 10000
## Initialissation aleatoire des niveaux de gris des departements
G<-sample(1:L,N,replace=T)
library(maptools)
setwd('C:/Users/benri/Dropbox/MasterProba/Simulation_et_Copules/Projet2')
fdc = readShapeSpatial("DEPARTEMENT")
couleurs = c("blue","red","yellow","green")
vect_couleurs = couleurs[G]
A=fdc
A$CODE_DEPT=as.numeric(as.character(A$CODE_DEPT))
ligne=which(is.na(A$CODE_DEPT))
A$CODE_DEPT[ligne]=20
A = A[order(A$CODE_DEPT),]
fdc=A[order(A$CODE_DEPT),]
coul = (1:L)[-vect_couleurs[20]]
Corse = sample(coul,1)
vect_couleurs=c(vect_couleurs[1:20],vect_couleurs[20],vect_couleurs[21:95])
#vect_couleurs=c(vect_couleurs[1:20],corse,vect_couleurs[21:95])
plot(fdc,col=vect_couleurs)
fctHCouleurs <- function(G){
output = 0
for (j in (2:N)){
for (i in (1:j)){
output = output + (V[i,j]==1 && G[i]==G[j])
}
}
return(output)
}
transition <- function(G,betta) {
Gnew = G
coord = sample(1:N,1)
piGibbs = rep(0,L)
for (i in (1:L)) {
Glocal = G
Glocal[coord] = i
piGibbs[i] = exp(-betta*fctHCouleurs(Glocal))
}
# normalisation
piGibbs = piGibbs/sum(piGibbs)
Gnew[coord] = sample(1:L,1,prob = piGibbs)
H = fctHCouleurs(Gnew)
maliste = list("G" = Gnew, "H" = H)
return(maliste)
}
# Metropolis
G<-sample(1:L,N,replace=T)
vecteurH = c()
vecteurH[1] = fctHCouleurs(G)
betta0 = 1
for (i in 2:nmax) {
betta = betta0 * sqrt(i)
maliste = transition(G,betta)
vecteurH[i] = maliste$H
G = maliste$G
}
plot(vecteurH)
print(fctHCouleurs(G))
library(maptools)
setwd('C:/Users/benri/Dropbox/MasterProba/Simulation_et_Copules/Projet2')
fdc = readShapeSpatial("DEPARTEMENT")
couleurs = c("blue","red","yellow","green")
vect_couleurs = couleurs[G]
A=fdc
A$CODE_DEPT=as.numeric(as.character(A$CODE_DEPT))
ligne=which(is.na(A$CODE_DEPT))
A$CODE_DEPT[ligne]=20
A = A[order(A$CODE_DEPT),]
fdc=A[order(A$CODE_DEPT),]
coul = (1:L)[-vect_couleurs[20]]
Corse = sample(coul,1)
vect_couleurs=c(vect_couleurs[1:20],vect_couleurs[20],vect_couleurs[21:95])
#vect_couleurs=c(vect_couleurs[1:20],corse,vect_couleurs[21:95])
plot(fdc,col=vect_couleurs)
re(list = ls)
remove(list = ls)
remove(list = ls())
N = 2000 # nombre maximal que peut atteindre une valeur
d = 1000 # nombre de valeurs  dans le vecteur
# Fonction Elementaires ---------------------------------------------------
fctH = function(vectValeurs,vectCoordones) {
loc1 = sum(vectValeurs*vectCoordones)
loc2 = sum(vectValeurs * (1-vectCoordones))
return(abs(loc1 - loc2))
}
transition1 = function(vectValeurs,vectCoord,betta) {
# on tire une valeur au hasard et on change son appartenance
coord = sample(1:d,1)
vectCoordNew = vectCoord
vectCoordNew[coord] = 1-vectCoordNew[coord]
Delta = fctH(vectValeurs,vectCoordNew)-fctH(vectValeurs,vectCoord)
alpha = min(exp(-betta * Delta),1)
logAlpha = min(-betta * Delta,0)
U = runif(1)
if(log(U) < logAlpha) {return(vectCoordNew)}
else { return(vectCoord)}
}
vectValeurs = sample(1:N,d,replace = TRUE)
vectCoord = sample(0:1,d,replace = TRUE)
nmax1 = 100
betta0 = 0.05
vectCoordBest = vectCoord
Hbest = fctH(vectValeurs,vectCoord)
valeursH = c()
for (i in 1:nmax1) {
betta = betta0 * sqrt(i)
vectCoord = transition1(vectValeurs,vectCoord,betta)
valeursH[i] = fctH(vectValeurs,vectCoord)
if(valeursH[i]<Hbest){
Hbest = valeursH[i]
vectCoordBest = vectCoord
}
}
plot(valeursH)
print(Hbest)
transition2 = function(vectValeurs,vectCoord,betta) {
bool = (sum(vectValeurs * vectCoord) > sum(vectValeurs* (1-vectCoord)))*1
# bool = 1 si la somme associee aux 1 du vecteur coordonnes est plus grande
# que la somme associee au 0 du vecteur coordonnes
vectCoordNew = vectCoord
coord = sample(which(vectCoord==bool),1)
vectCoordNew[coord] = 1 - vectCoordNew[coord]
Delta = fctH(vectValeurs,vectCoordNew)-fctH(vectValeurs,vectCoord)
Qxy = 1/(length(which(vectCoord == vectCoord[coord])))
# la somme des elements dans l'autre ensemble que coord + la valeur de celui-ci
terme1 = sum(vectValeurs* (1-bool)) + vectValeurs[coord]
# la somme des elements dans le mm ensemble que coord - la valeur de celui-ci
terme2 = sum(vectValeurs * bool) - vectValeurs[coord]
if(terme1 < terme2) {
# Dans ce cas la transition de y a x est impossible et la transition de x a y est toujours accepte
Qyx = 0
}
else{
Qyx = 1/(length(which(vectCoord == 1-vectCoord[coord]))+1)
}
# on passe a l'echelle logarithmique pour qu'on ait pas un underflow numerique a cause des grandes valeurs
logAlpha = min((-betta * Delta)+ log(Qxy)-log(Qyx),0)
U = runif(1)
#print(alpha)
if(log(U) < logAlpha) {return(vectCoordNew)}
else { return(vectCoord)}
}
vectValeurs = sample(1:N,d,replace = TRUE)
vectCoord = sample(0:1,d,replace = TRUE)
nmax2 = 1000
betta0 = 0.2
vectCoordBest = vectCoord
Hbest = fctH(vectValeurs,vectCoord)
valeursH = c()
for (i in 1:nmax2) {
betta = betta0 * sqrt(i)
vectCoord = transition2(vectValeurs,vectCoord,betta)
valeursH[i] = fctH(vectValeurs,vectCoord)
if(valeursH[i]<Hbest){
Hbest = valeursH[i]
vectCoordBest = vectCoord
}
}
plot(valeursH)
print(Hbest)
